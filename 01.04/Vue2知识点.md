# 1、Vue2

##### 1.Vue的特点

- 遵循MVVM模式
- 编码简洁，体积小，运行效率高，适合移动/PC端开发
- 它本身只关注UI，可以引入其它第三方库开发项目

##### 2.data为什么是个函数

如果data是⼀个函数的话，这样每复⽤⼀次组件，就会返回⼀份新的data，类似于给每个组件实例创建⼀个私有的数据空间，让各个组件实例维护各⾃的数据。⽽单纯的写成对象形式，就使得所有组件实例共⽤了⼀份data，就会造成⼀个变了全都会变的结果。所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计⽆关。

##### 3.生命周期

我理解的生命周期函数就是 vue 实例从创建到销毁的过程中，到了某一个特定的时间节点会自动触发的钩子函数
常用的钩子函数一共有八个
beforeCreate 创建前 实例还未创建
created 创建后 这个第一个能拿到 date 和 methods 来用的钩子函数
beforeMount 挂载前 挂载的是节点
mounted 挂载后
以上四个是创建阶段的钩子函数 这些钩子函数只会执行 1 次

beforeUpdate 数据变了视图未更新
updated 数据变了 视图更新
更新阶段的钩子函数会执行 0 次或者无数次

beforeDestory 销毁之前 最后一个能使用 data 和 methods 的钩子函数
destoryed 销毁之后
销毁阶段的钩子函数 执行 1 次

除了这八个还有三个
actived 激活缓存组件
deactived 停用缓存组件
errorCaptured 子组件出错的时候触发

##### 4.Vue模板语法

Vue模板语法有两大类： 

1. 插值语法： 

   功能：用于解析标签体内容

   写法：`{{xxx}}`，xxx是js表达式，且可以直接读取到data中的所有区域

2. 指令语法： 

   功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）

   举例：<a v-bind:href="xxx">或简写为<a :href="xxx"> , xxx同样要写js表达式，且可以直接读取到data中的所有属性 

   备注：Vue中有很多的指令，且形式都是v-xx

##### 5.数据绑定

1. 单向绑定（`v-bind`）：数据只能从data流向页面

2. 双向绑定（`v-model`）：数据不仅能从data流向页面，还可以从页面流向data

   备注： 

   1. 双向绑定一般都应用在表单类元素上（ 如：<input>、 <select> 、<textarea>  等 ）
   2. `v-model:value`可以简写为`v-model`，因为`v-model`默认收集的就是value值

##### 6.MVVM模型

MVVM**模式的优点：**

1. 1、低耦合： 视图（View）可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定到不同的"View"上，当View变化的时候Model
2. 可以不变，当Model变化的时候View也可以不变。2、可重⽤性： 你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多 view 重⽤这段视图逻辑。
3. 3、独⽴开发： 开发⼈员可以专注于业务逻辑和数据的开发（ViewModel），设计⼈员可以专注于⻚⾯设计。
4. 4、可测试： 界⾯素来是⽐较难于测试的，⽽现在测试可以针对ViewModel来写

1. MVVM **和** MVC **的区别：**
2. mvc 和 mvvm 其实区别并不⼤。都是⼀种设计思想。
3. 主要区别
4. mvc 中 Controller演变成 mvvm 中的 viewModel，
5. mvvm 通过数据来显示视图层⽽不是节点操作。
6. mvvm主要解决了:
7. mvc中⼤量的DOM 操作使⻚⾯渲染性能降低，加载速度变慢，影响⽤户体验

##### 7.Vue中的数据代理

1. Vue中的数据代理通过vm对象来代理data对象中属性的操作（读/写）
2. Vue中数据代理的好处：更加方便的操作data中的数据
3. 基本原理： 
   - 通过`object.defineProperty()`把data对象中所有属性添加到vm上。
   - 为每一个添加到vm上的属性，都指定一个getter/setter。
   - 在getter/setter内部去操作（读/写）data中对应的属性。

##### 8. 事件修饰符

1. prevent：阻止默认事件（常用）
2. stop：阻止事件冒泡（常用）
3. once：事件只触发一次（常用）
4. capture：使用事件的捕获模式
5. self：只有`event.target`是当前操作的元素时才触发事件
6. passive：事件的默认行为立即执行，无需等待事件回调执行完毕

7. 修饰符可以连续写，比如：`@click.prevent.stop="showInfo"` 

##### 9. 键盘事件

- 回车：enter
- 删除：delete (捕获“删除”和“退格”键)
- 退出：esc
- 空格：space
- 换行：tab (特殊，必须配合keydown去使用)
- 上：up
- 下：down
- 左：left
- 右：right

##### 10.计算属性

- 定义：要用的属性不存在，需要通过已有属性计算得来。
- 原理：底层借助了`Objcet.defineproperty()`方法提供的getter和setter。
- get函数什么时候执行？ 
  - 初次读取时会执行一次
  - 当依赖的数据发生改变时会被再次调用

- 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便
- 备注： 
  - 计算属性最终会出现在vm上，直接读取使用即可
  - 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变
  - 如果计算属性确定不考虑修改，可以使用计算属性的简写形式

##### 11. 模块

- 理解：向外提供特定功能的 js 程序，一般就是一个 js 文件
- 为什么：js 文件很多很复杂
- 作用：复用 js，简化 js 的编写，提高 js 运行效率

##### 12.模块化、组件化

-  当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用 

   -  当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用 	 	

##### 13.组件

- 定义：用来实现局部功能的代码和资源的集合
- 为什么：一个界面的功能很复杂
- 作用：复用编码，简化项目编码，提高运行效率

##### 14.组件基本使用

Vue中使用组件的三大步骤： 

- 定义组件(创建组件)
- 注册组件
- 使用组件(写组件标签)

##### 15.过滤器

- 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
- 有全局过滤器和局部过滤器
- 语法： 
  - 注册过滤器：`Vue.filter(name,callback)` 或 `new Vue{filters:{}}`
  - 使用过滤器：`{{ xxx | 过滤器名}}` 或 `v-bind:属性 = "xxx | 过滤器名"`

- 备注： 
  - 过滤器可以接收额外参数，多个过滤器也可以串联
  - 并没有改变原本的数据，而是产生新的对应的数据

##### 16.v-if 与 v-show 的区别

v-if：动态创建或移除元素，实现元素的显示与隐藏

v-show：动态为元素添加和移除 display: none 样式，实现元素的显示与隐藏

性能区别：
如果要频繁的显示和隐藏，v-show的性能更好，因为动态创建和移除元素浏览器会出现重绘等机制，所以会消耗更多的性能。
如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能更好。

##### 17.⽗⼦组件⽣命周期执⾏的顺序

1. 页面—beforeCreate
2. 页面—created
3. 页面—beforeMount
4. 组件—beforeCreate
5. 组件—created
6. 组件—beforeMount
7. 组件—mounted
8. 页面—mounted

##### 18.keep-alive

当组件进行切换的时候，一般默认会把页面进行销毁，而keep-alive是vue的一个内置组件，作用就是保存组件的状态，让他不被销毁，
组件使用keep-alive之后会新增两个生命周期activated，和deactivated，activated是激活，deactivated是失活。
当遇到有些组件不需要缓存时，这个时候就可以用到keep-alive标签的两个属性，include属性和exclude属性 ：
include（白名单）属性定义了要缓存谁，exclude（黑名单）属性定义了不缓存谁，要想黑白名单生效，可以通过name来让属性生效

##### 19.v-for 与 v-if 的优先级

v-for 的优先级⾼. 因为 v-for 的时候我们才开始渲染 dom 元素,这个 v-if 还⽆法进⾏判断.

v-for 和 v-if 不能同时使⽤,我们可以通过标签,⽐如 div 或者 template 标签来进⾏包裹,把 v-if 写到包裹的标签上⾯(写到 v-for 外⾯)

##### 20.vue 中 key 的作⽤

避免 dom 元素重复渲染.
 我⻔⼀般在设置 key 的时候⾸先尽量会设置为 id,或者 index 下表.key的值是唯一的

##### 21.vue双向数据绑定原理

1、vue双向数据绑定是 通过 数据劫持 并结合 发布-订阅模式 的方法来实现的。 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变。
2、其中 数据劫持 是通过 Object.defineProperty() 方法实现的。vue 在内部会把定义在 data 中的属性通过这个方法全部转为 getter/setter。
3、在数据变动时发布消息给订阅者，触发相应的监听回调。这个时候就可以实现数据的双向绑定

##### 22. vue 常⽤的指令

1. v-if ：判断是否显示隐藏
2. v-for：数据循环
3. v-bind：绑定属性
4. v-model: 实现数据双向绑定
5. v-show:判断隐藏显示
6. v-on: 事件绑定指令,可以简写为@
7. 内容渲染指令：v-text：作用：将对应的值渲染到元素内部缺点：会覆盖元素内部原有的内容                                                                v-html：可以把包含HTML标签的字符串渲染为页面的HTML元素。

##### 23.diff算法

Diff算法的步骤：
1.js 对象表示真实的 dom 结构，就是我们说的生成一个虚拟 dom，再用虚拟 dom 构建一个真的 dom 树，放到页面中。 
2.状态改变的时候生成一个新的虚拟 dom 跟旧的进行对比，这个对比的过程就是 diff 算法，通过 patch 对象记录差异 
3.把记录的差异用在第一个虚拟 dom 构建的真实的 dom 上，视图就更新了

Vue 的 diff 算法是平级⽐较，不考虑跨级⽐较的情况。内部采⽤深度递归的⽅式+双指针⽅式⽐较

diff 算法就是对虚拟 dom 进行对比，并返回一个 patch 对象，这个对象的作用是存储两个节点不同的地方，最后用 patch 里记录的信息去局部更新真实的 dom

##### 24.虚拟 dom

虚拟dom就是一个普通的js对象。是一个用来描述真实dom结构的js对象，因为他不是真实dom，所以才叫虚拟dom。
虚拟dom可以很好的跟踪当前dom状态，因为他会根据当前数据生成一个描述当前dom结构的虚拟dom，然后数据发送变化时，又会生成一个新的虚拟dom，而这两个虚拟dom恰恰保存了变化前后的状态。然后通过diff算法，计算出两个前后两个虚拟dom之间的差异，得出一个更新的最优方法（哪些发生改变，就更新哪些）。可以很明显的提升渲染效率以及用户体验。

##### 25.插槽

插槽就是⼀个占位符,将⾃定义组件的内容展示出来

插槽分别具名插槽和匿名插槽、以及作⽤域插槽. 我们⽤的⽐较多的具名插槽和匿名插槽,
具名插槽需要所有 slot 标签上指定name 属性,⽽在对应标签上添加# 属性指定名字.
作用域插槽
是把子组件里的数据传到父组件的插槽里使用

##### 26.过滤器 filter

所谓的 vue 过滤器就是将数据进⾏⼆次处理,得到我们想要的结果数据
vue 的过滤器分为两种,第⼀种是全局过滤器,通过 vue.filter 来进⾏定义,第⼆种是局部过滤器,需要定义在组件内部，用 filters 过滤
项⽬中我们通过过滤器将后台返回的状态 0 和 1 转化为⽀付或者未⽀付 还有对时间格式进行过滤

##### 27.组件通信

父传子
在父组件中的子组件的标签上 添加自定义属性，在子组件中通过 props 来接收，在接收的时候有两种接收方式 数组形式 和 对象形式 。对象形式可以规定传来的变量的数据类型（type）默认值（default）以及是否必填（required）

子传父
首先在使用子组件的标签上定义一个自定义事件 在子组件里通过 this.$emit 去调用这个自定义事件 $emit 方法的第一个参数是自定义事件的名字 第二个参数是就是子组件要传递给父组件的变量 最后在父组件接收使用就可以了

兄弟组件
利用中央事件总线 eventbus把一个空的 vue 实例挂载在 vue 的原型上起名叫$bus传数据的时候用this.$bus.$emit传 在要接受数据的子组件 在 created钩子函数中 用$on 方法接收

利用 vuex 进行组件通信 把公共的数据存在 vuex 里就可以实现组件之间都能使用这个数据了

##### 28.methods computed watch

 methods 就是方法 我们写的点击事件等各种事件都放在 methods 里

计算属性 computed 计算属性 有缓存功能就是当跟他有关的值发生变化的时候才会重新计算 还有一个特点就是必须要有 return 值 return 就是把计算的结果 return 出去

watch 可以用来监听 数据和路由的变化
watch 有三个参数 deep immediate handler
当我们不需要 deep 和 immediate 的时候 就可以简写为一个函数 这个函数就是 handler

##### 29.导航守卫

路由的导航守卫 又叫做路由的钩子函数（生命周期函数）就是在跳转页面的 时候把 路由拦下来 做一些操作 再放行

1.全局守卫 beforeEach 路由进入之前  afterEach 路由进入之后

2.组件内守卫 beforeRouteEnter 路由进入之前  beforeRouteUpdate 路由更新之前  beforeRouteLeave 路由离开之前

3.独享守卫 beforeEnter 路由进入之前

都有三个参数：to from next
to：从哪里来；from：到哪里去；next：下一步，放行
next 参数 除了括号里可以是空和路径之外 还可以是一个回调函数（回调函数就是一个被作为参数传递的函数）
next 这个参数 在vu2中是必须的但是到了vue3的时候 next 参数变成可选的了

全局 组件 独享守卫的区别：
1. 作用范围不同 全局作用于所有页面 组件作用于单个组件 独享也是守卫单个页面
2. 代码写的位置不一样 全局守卫写在 router/index.js 中 组件守卫写在组件里 跟 data 同级 独享守卫写在路由规则里
3. 执行顺序有区别 执行的顺序要记下来
   beforeEach 前置守卫
   beforeEnter 独享守卫
   beforeRouteEnter 组件守卫
   beforeResolve 解析守卫
   afterEach 路由后置守卫

##### 30.vuex 

###### 运行机制

在项⽬当中如果要改变 state 的状态,我们⼀般是在组件⾥⾯调⽤ this.$store.dispatch ⽅式来触发 actions ⾥⾯的⽅法,在actions⾥⾯的⽅法通过 commit 来调⽤ mutations ⾥⾯定义的⽅法来改变 state,同时这也是 vuex 的执⾏机制

###### Vuex理解

vuex 是 vue 的状态管理工具 管理项目中的公共数据 能够在所有的组件中使用
一共有五大核心：
state 存放公共数据的地方 通过 this.$store.state.xxx调用
mutations 修改 state 的地方 只有这里能修改 通过this.$store.commit 调用
getters 相当于是之前的计算属性 通过 this.$store.getters 调用
actions 执行异步操作的地方 通过 this.$store.dispatch 调用
modules 模块化
vuex 缺点就是刷新数据会丢失 我们可以保存本地存储 或者 安装 vuex 持久化插件 vuex-persist 去实现自动本地存储

##### 31.路由的模式 以及原理

###### 1.哈希模式

1、hash模式是比较好区分的，凡是我们的url后带有“#”的都属于hash模式；
2、hash“#”后的值，不会包含在http请求中，改变hash的值不会引起页面的重新载
3、hash可以兼容到ie8以上

###### 2. history模式

1、url不带参数，所以看起来比较美观
2、history依赖于前后端交互，即将url修改的就和正常请求的后端url一样，如后端没有配置对应的/user/id的路由处理，就会返回404错误
3、history可以兼容到ie10
history的原理就是利⽤html5新增的两个特性⽅法,分是pushState和replaceState来完成的